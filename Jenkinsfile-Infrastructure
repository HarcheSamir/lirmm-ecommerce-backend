// This is the final, correct infrastructure pipeline.
// Its ONLY job is to create or reset the infrastructure (databases, Kafka, etc.).
// It does NOT touch the application services.
pipeline {
    agent { label 'wsl' }

    environment {
        ISTIO_BIN_DIR         = '/home/samir/istio-1.26.3/bin'
        APP_NAMESPACE       = 'lirmm-services'
        INFRA_MANIFEST_FILE = './kind-deployment/infra-manifests.yaml'
        KIND_CLUSTER_NAME   = "lirmm-dev-cluster"
    }

    stages {
        stage('Setup Kind Cluster and Istio') {
            steps {
                script {
                    def publicImages = [
                        'postgres:15-alpine', 'confluentinc/cp-zookeeper:7.3.2',
                        'confluentinc/cp-kafka:7.3.2', 'docker.elastic.co/elasticsearch:elasticsearch:8.11.1',
                        'redis:7.2-alpine'
                    ]
                    sh "chmod +x ./kind-deployment/setup-kind.sh"
                    withEnv(["PATH+EXTRA=${env.ISTIO_BIN_DIR}"]) { sh "./kind-deployment/setup-kind.sh" }
                    
                    echo "--- Pre-pulling and loading public images ---"
                    publicImages.each { image ->
                        sh "docker pull ${image}"
                        sh "kind load docker-image ${image} --name ${env.KIND_CLUSTER_NAME}"
                    }
                }
            }
        }
        
        stage('Deploy & Refresh Infrastructure Services') {
            steps {
                script {
                    echo "--- Applying ALL infrastructure manifests ---"
                    sh "kubectl apply -f ${env.INFRA_MANIFEST_FILE} -n ${env.APP_NAMESPACE}"
                    
                    echo "--- Restarting ALL infrastructure to wipe data ---"
                    sh "kubectl rollout restart deployment -n ${env.APP_NAMESPACE} -l 'component in (zookeeper, kafka, elasticsearch, redis, database)'"
                }
            }
        }

        stage('Wait for Infrastructure to be Healthy') {
            steps {
                script {
                    echo "--- Waiting for infrastructure pods to become 'Available' (first check)... ---"
                    sh "kubectl wait --for=condition=Available deployment -l 'component in (zookeeper, kafka, elasticsearch, redis, database)' -n ${env.APP_NAMESPACE} --timeout=15m"
                    
                    echo "--- Actively polling Postgres databases until they accept connections (second, deeper check)... ---"
                    def databases = ['auth-db-svc', 'product-db-svc', 'order-db-svc', 'review-db-svc', 'stats-db-svc']
                    databases.each { dbSvc ->
                        echo "Verifying connection to ${dbSvc}..."
                        // This will retry for up to 2 minutes for each database.
                        retry(24) {
                            sh """
                            kubectl run db-checker-${dbSvc} --rm=true --attach=true -i \\
                                --namespace ${env.APP_NAMESPACE} \\
                                --image=postgres:15-alpine \\
                                --restart=Never -- \\
                                sh -c 'pg_isready -h ${dbSvc} -p 5432 -U postgres || exit 1'
                            """
                            // We don't need a sleep inside retry, it handles backoff.
                        }
                        echo "${dbSvc} is ready."
                    }
                    
                    echo "--- Infrastructure is confirmed to be healthy and ready. ---"
                }
            }
        }
    }
    post {
        success {
            echo "--- INFRASTRUCTURE DEPLOYMENT SUCCEEDED ---"
            echo "--- The data platform is now clean and ready. You can now run the Application pipeline. ---"
        }
        failure {
            echo "--- INFRASTRUCTURE DEPLOYMENT FAILED ---"
        }
    }
}