// Jenkinsfile-Infrastructure (FINAL CORRECTED VERSION)
pipeline {
    agent { label 'wsl' }

    environment {
        REGISTRY_HOST         = 'localhost:5000'
        APP_NAMESPACE         = 'lirmm-services'
        INFRA_MANIFEST_FILE   = './kind-deployment/infra-manifests.yaml'
        KIND_CLUSTER_NAME     = "lirmm-dev-cluster"
        KIND_CONFIG_FILE      = "./kind-deployment/kind-cluster-config.yaml"
        KIND_SETUP_SCRIPT     = "./kind-deployment/setup-kind.sh"
        ISTIO_BIN_DIR         = '/home/samir/istio-1.26.3/bin'
        INFRA_IMAGES = """
            confluentinc/cp-zookeeper:7.3.2
            confluentinc/cp-kafka:7.3.2
            docker.elastic.co/elasticsearch/elasticsearch:8.11.1
            redis:7.2-alpine
            postgres:15-alpine
        """
    }

    parameters {
        choice(name: 'MODE', choices: ['BOOTSTRAP', 'RESET_DATA_ONLY'], description: 'BOOTSTRAP: Creates cluster+Istio+addons & infra. RESET_DATA_ONLY: Fast data wipe.')
    }

    stages {
        stage('Bootstrap Cluster and Infrastructure') {
            when { expression { params.MODE == 'BOOTSTRAP' } }
            steps {
                script {
                    echo "--- BOOTSTRAP MODE ---"

                    // Pre-pull images first. This is safe to run anytime.
                    echo "Pre-pulling and pushing infra images to local registry for speed..."
                    def images = INFRA_IMAGES.trim().split('\\s+')
                    images.each { imageName ->
                        echo "Processing image: ${imageName}"
                        sh """
                            docker pull ${imageName}
                            docker tag ${imageName} ${REGISTRY_HOST}/${imageName}
                            docker push ${REGISTRY_HOST}/${imageName}
                        """
                    }

                    // The setup script is now the single source of truth for cluster creation and Istio install.
                    withEnv(["PATH+ISTIO=${env.ISTIO_BIN_DIR}"]) {
                        echo "Running setup script to ensure cluster and Istio are installed..."
                        sh "chmod +x ${KIND_SETUP_SCRIPT}"
                        sh "${KIND_SETUP_SCRIPT}"
                    }

                    // This must run *after* the cluster is confirmed to exist.
                    echo "Connecting local registry to Kind network..."
                    sh 'docker network connect "kind" "kind-registry" || echo "Registry already connected, continuing..."'

                    echo "Deploying infrastructure services (Databases, Kafka, Redis, ES)..."
                    sh "kubectl apply -f ${INFRA_MANIFEST_FILE}"

                    echo "Waiting for all infrastructure to be ready..."
                    sh "kubectl wait --for=condition=available deployment -n ${APP_NAMESPACE} --all --timeout=15m"
                }
            }
        }

        stage('Reset Data Only (Fast)') {
            when { expression { params.MODE == 'RESET_DATA_ONLY' } }
            steps {
                script {
                    echo "--- RESET DATA ONLY MODE ---"
                    echo "Deleting all stateful service pods to wipe data (this is fast)..."
                    sh "kubectl delete pods -n ${APP_NAMESPACE} -l component=zookeeper --ignore-not-found=true"
                    sh "kubectl delete pods -n ${APP_NAMESPACE} -l component=kafka --ignore-not-found=true"
                    sh "kubectl delete pods -n ${APP_NAMESPACE} -l component=elasticsearch --ignore-not-found=true"
                    sh "kubectl delete pods -n ${APP_NAMESPACE} -l component=redis --ignore-not-found=true"
                    sh "kubectl delete pods -n ${APP_NAMESPACE} -l component=database --ignore-not-found=true"
                    
                    echo "Waiting for infrastructure to come back online..."
                    sh "kubectl wait --for=condition=available deployment -n ${APP_NAMESPACE} --all --timeout=10m"
                }
            }
        }
    }

    post {
        success {
            echo "INFRA PIPELINE SUCCEEDED. The system is ready for the application pipeline."
        }
        failure {
            error "INFRA PIPELINE FAILED."
        }
    }
}